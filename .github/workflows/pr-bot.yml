name: Auto-Comment on PR

on:
  pull_request_target:
    types: [opened, synchronize, reopened, edited]

jobs:
  welcome:
    permissions:
      pull-requests: write
      contents: read
      issues: write
    runs-on: ubuntu-latest
    steps:
      - name: Post Comment
        uses: actions/github-script@v8
        with:
          script: |
            //
            // Preamble stuff
            // Probably no need to touch
            //

            const marker = "our-nice-little-helper-bot-983247854" // used for comment updates
            const { repository, pull_request: pr } = context.payload;
            const { issues, pulls, repos } = github.rest;
            const auth = { owner: context.repo.owner, repo: context.repo.repo };
            const base = `${repository.html_url}/blob/${repository.default_branch}`;

            const body = [
              `<!--${marker}-->`,
              "#### Thanks for opening this PR! We'll review it soon.",
              "I'm a bot that checks for some common problems. I'll update this comment with anything I find."
            ];

            console.log(JSON.stringify(pr)); // for debugging

            const link = f => `[${f}](${base}/${f})`;

            //
            // Message body stuff
            // Push string to body array to add new sections
            //

            const newFace = await (async () => {
              console.log("newFace", pr.author_association);
              if (pr.author_association === "FIRST_TIME_CONTRIBUTOR")
                return true;
              const commits = await repos.listCommits({...auth, author: pr.user.login})
                .then(({data: commits}) => commits.map(c => c.sha.substring(0,8)));
              console.log("newFace", commits);
              return commits.length === 0;
            })();

            const canModify = (() => {
              console.log("canModify", pr.head.repo.full_name, pr.base.repo.full_name, pr.maintainer_can_modify);
              return pr.head.repo.full_name === pr.base.repo.full_name || pr.maintainer_can_modify;
            })();

            const checkboxProblem = (() => {
              const expected = "- [ ] I have reviewed [CONTRIBUTING.md] and agree to its terms.";
              const pattern = /- \[ *(.*) *\] I have reviewed \[CONTRIBUTING\.md\](\(.+\))? and agree to its terms\./i;

              if (!pattern.test(expected)) throw new Error("expected string does not match test string");
              const match = pattern.exec(pr.body);
              console.log("checkboxProblem", match);
              if (!match) {
                return `Ensure this checkbox is in the PR: '${expected}'`;
              } else if (match[1].length === 0) {
                return `Please agree to the terms in ${link("CONTRIBUTING.md")}, by checking the box in the description.`;
              }
              return false;
            })();

            const updated = (await github.paginate(pulls.listFiles, {
              ...auth, pull_number: context.issue.number,
            })).map(f => f.filename);
            console.log("updated", updated);

            const blockers = [];
            const quibbles = [];

            // stuff for first time contributors
            if (newFace)
            {
              const temp = [];

              temp.push([
                "-",
                "Welcome the community and thank you for your contribution!",
                `Please take a moment to familiarize yourself with the resources available in our ${link("README.md")} file.`,
              ].join(" "));

              if (!updated.some(file => file === "CONTRIBUTORS"))
              {
                temp.push([
                  "-",
                  `Please take a moment to add your name to the bottom of the ${link("CONTRIBUTORS")} file!`,
                ].join(" "));
              }

              if (checkboxProblem)
              {
                temp.push([
                  "-",
                  `Please ensure you have read ${link("CONTRIBUTING.md")} and agree to its terms.`,
                  "We cannot accept code before this is done.",
                ].join(" "));
              }

              if (temp.length > 0)
              {
                body.push(
                  "#### Looks like it's your first time contributing!",
                  ...temp,
                );
              }
            }

            if (checkboxProblem)
            {
              blockers.push(`- ${checkboxProblem}`);
            }

            if (!canModify)
            {
              quibbles.push([
                "-",
                "While it is not required, allowing edits by maintainers will speed up the review process.",
                "We require PRs to be up-to-date in order to merge them, and this permission allows us to quickly rebase the PR in order to merge it.",
              ].join(" "));
            }

            // notify about subtree edits in quibbles section
            const subtrees = [
              "libraries/Translation/",
              "libraries/ZMusic/",
              "libraries/ZWidget/",
              "libraries/ZVulkan/",
            ];
            for (const subtree of subtrees)
            {
              if (updated.some(file => file.startsWith(subtree)))
              {
                quibbles.push([
                  "-",
                  `Head's up, \`${subtree}\` is a subtree.`,
                  "Please ensure you're pushing these changes upstream.",
                ].join(" "));
              }
            }

            if (blockers.length > 0)
            {
              body.push(
                "#### Here are some issues, that must be fixed:",
                ...blockers,
              );
            }

            if (quibbles.length > 0)
            {
              body.push(
                "#### Here are some minor issues, that might need fixing:",
                ...quibbles,
              );
            }

            if (blockers.length === 0 && quibbles.length === 0)
            {
              body.push(
                "#### Nothing to report. Nice :)"
              );
            }

            //
            // Create / Update comment stuff
            // Probably no need to touch
            //

            const data = { ...auth, body: body.join("\n") };

            console.log(data);

            const { data: comments } = await issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });
            const oldComment = comments.find(c => c.body.includes(marker));

            if (oldComment) {
              await issues.updateComment({
                ...data, comment_id: oldComment.id
              });
            } else {
              await issues.createComment({
                ...data, issue_number: context.issue.number
              });
            }

            if (blockers.length > 0)
            {
              core.setFailed(`There are ${blockers.length} issue(s) that need resolving. See the bot's comment for details`);
            }
